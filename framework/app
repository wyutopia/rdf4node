#!/usr/bin/env node
/**
 * Created by Eric on 2021/11/10
 * Updatede by Eric on 2024/01/19
 */
// Node libs
const assert = require('assert');
const appRoot = require('app-root-path');
const async = require('async');
const EventEmitter = require('events');
const fs = require('fs');
const path = require('path');
const os = require('os');
// project libs
const sysdefs = require('../include/sysdefs');
const eRetCodes = require('../include/retcodes');
const { eSysEvents: eDomainEvent } = require('../include/events');
const tools = require('../utils/tools');
//
const promMonitor = require('../libs/base/prom.monitor');
const logDirManager = require('../utils/logdir.manager');
//
const { Registry } = require('./registry');
const { DataSourceFactory } = require('./data-source');
const { EventBus, EventLogger } = require('./ebus');
const { RepositoryFactory } = require('./repository');
const { CacheFactory } = require('./cache');
const { EndpointFactory } = require('./endpoint');
const { DistributedEntityLocker } = require('./distributed-locker');
const { TaskFactory } = require('./xtask');
//
const { WinstonLogger } = require('../libs/base/winston.wrapper');
const logger = WinstonLogger(process.env.SRV_ROLE || 'app');
//
function _regService(callback) {
    if (consulClient === null) {
        logger.warn(`>>>>>> Consul not configged! -ignore register service.`);
        return callback();
    }
    let localIp = tools.getLocalIp()[0];
    let port = process.env.PORT || appConf.port || 3000;
    consulClient.regService({
        name: appConf.registry,
        id: this._id,
        tags: appConf.tags,
        address: localIp,
        port: parseInt(port, 10),
        check: {
            http: `http://${localIp}:${port}/monitor/health`,
            interval: '15s'
        }
    }, (err) => {
        if (err) {
            logger.error('Register to consul error!');
        } else {
            logger.info('Register to consul succeed.');
            consulSignIn = true;
        }
        return callback();
    });
}

function _deregService(callback) {
    if (!this.consulClient) {
        logger.warn(`>>>>>> Consul not configged! - ignore de-register service.`);
        return callback();
    }
    logger.info('Try to de-register from consul...');
    if (!consulSignIn) {
        logger.error('Not registered!');
        return callback();
    }
    consulClient.deregService({
        id: this._id
    }, (err) => {
        if (err) {
            logger.error('De-register from consul failed.');
        } else {
            logger.info('De-register from consul succeed.');
        }
        return callback();
    });
}

function _fireStartupAlarm(callback) {
    let options = {
        eventId: sysdefs.eAlarmCode.SERVICE_STARTUP,
        content: 'This is a startup alarm test!'
    }
    return this.fireAlarm(options, callback);
}

function _fireExitAlarm(callback) {
    let options = {
        eventId: sysdefs.eAlarmCode.GRACEFUL_EXIT,
        content: 'This is a graceful-exit alarm test!'
    }
    return this.fireAlarm(options, callback);
}

function _buildModuleArch() {
    let arch = {};
    Object.keys(sysdefs.eModuleType).forEach(layer => {
        arch[layer.toLowerCase()] = [];
    });
    return arch;
}

const _typeAppConfig = {
    id: os.hostname(),
    name: 'a9kb',
    alias: 'a9kb-app',
    registry: 'a9kb-app',
    version: 'a.b.c',
    tags: [],
    //
    arch: _buildModuleArch(),
    state: sysdefs.eModuleState.INIT,
    //
    enableMonitor: false,
    security: {
        ip: false,
        encryptKey: '123abcABC',
        expiresIn: "72h",
        enableRateLimit: false,
        enableAuthentication: true,
        enableAuthorization: false
    },
    rateLimit: {
        options: {
            windowMs: 60000,
            max: 60,
            expireTimeMs: 900000
        },
        store: {
            type: 'mongo',
            confPath: 'dataSources.default.config'
        }
    },
    defaultDataSource: 'default'
}

function _initSelf(props) {
    Object.keys(_typeAppConfig).forEach(key => {
        const propKey = '_' + key;
        this[propKey] = props[key] !== undefined? props[key] : _typeAppConfig[key];
    })
}

const _excludeModelPaths = ['.DS_Store', '_templates'];
function _readModelDirSync(modelDir, loadedModels, options) {
    //logger.debug(`====== Scan directory: ${modelDir}`);
    let entries = fs.readdirSync(modelDir, {
        withFileTypes: true
    });
    entries.forEach(dirent => {
        if (options.excludeModelPaths.indexOf(dirent.name) !== -1) { // Ignore excluded paths
            return null;
        }
        let fullPath = path.join(modelDir, dirent.name);
        if (dirent.isDirectory()) { // Recursive directory
            return _readModelDirSync.call(this, fullPath, loadedModels, options);
        }
        //
        try {
            const modelSpec = require(fullPath);
            const modelName = modelSpec.modelName;
            if (options.includeModels && options.includeModels.indexOf(modelName) === -1) {
                return null;
            }
            //
            let cacheConf = options.caches[modelName] || {};
            // Get allowCache switch
            let allowCache = ((allowCache, cfg) => { // cache config has the privilege
                return cfg.enabled !== undefined ? cfg.enabled : (allowCache !== undefined ? allowCache : false);
            })(modelSpec.allowCache, cacheConf);
            // Assemble cacheOptions = cacheSpecProps + cacheEntityProps
            let cacheSpec = Object.assign({}, modelSpec.cacheSpec, cacheConf.spec);
            this.repoFactory.registerSchema(modelName, {
                schema: modelSpec.modelSchema,
                refs: modelSpec.modelRefs || [],
                // Cache options
                allowCache,
                cacheSpec
            });
            logger.debug(`${modelName} cache settings: ${allowCache} - ${tools.inspect(cacheSpec)}`);
            loadedModels.push(modelName);
        } catch (ex) {
            logger.error(`====== Load database schema from: ${dirent.name} error! - ${ex.message}`);
        }
    });
}

// The application class
class Application extends EventEmitter {
    constructor(props) {
        super();
        // Declaring member variables
        _initSelf.call(this, props);
        this._modules = {};
        //
        this.ebus = new EventBus(this, {$name: sysdefs.eFrameworkModules.EBUS});
        this.taskFactory = new TaskFactory(this, {$name: sysdefs.eFrameworkModules.XTASK});
        this.registry = new Registry(this, {$name: sysdefs.eFrameworkModules.REGISTRY});
        this.dsFactory = new DataSourceFactory(this, { $name: sysdefs.eFrameworkModules.DATASOURCE });
        this.repoFactory = new RepositoryFactory(this, { $name: sysdefs.eFrameworkModules.REPOSITORY });
        this.cacheFactory = new CacheFactory(this, {$name: sysdefs.eFrameworkModules.CACHE});
        this.distLocker = new DistributedEntityLocker({$name: sysdefs.eFrameworkModules.DLOCKER});
        this.epFactory = new EndpointFactory(this, {$name: sysdefs.eFrameworkModules.ENDPOINT});
    }
    getVersion() {
        if (this._version === null) {
            const pkgJson = JSON.parse(fs.readFileSync(path.join(appRoot, 'package.json'), 'utf8'));
            this._version = pkgJson.version;
        }
        return this._version;
    }
    // Implementing member methods
    getName() {
        logger.debug(`>>> The application name: ${this._name}`);
        return this._name;
    }
    getId() {
        logger.debug(`>>> The application id: ${this._id}`);
        return this._id;
    }
    getInstance() {
        return this._id;
    }
    setState(s) {
        this._state = s;
    }
    getState() {
        return this._state;
    }
    fetchServices(callback) {
        return _consulClient.listServices(callback);
    }
    getDataSource(...args) {
        return this.dsFactory.getDataSource(...args);
    }
    getCache(...args) {
        return this.cacheFactory.getCache(...args);
    }
    //
    /**
     * 
     * @param { Object } config - The framework config
     * @param { Object? } config.registry
     * @param { Object? } config.dataSources
     * @param { Object? } config.eventBus
     * @returns 
     */
    async initFramework(config) {
        if (this._state !== sysdefs.eModuleState.INIT) {
            return Promise.reject({
                code: eRetCodes.INTERNAL_SERVER_ERR,
                message: 'Framework components already initialized.'
            });
        }
        promMonitor.init(this);
        logDirManager.init(this);

        if (config.registry) {
            this.registry.init(config.registry);
        }
        if (config.dataSources) {
            this.dsFactory.init(config.dataSources);
        }
        if (config.eventBus) {
            this.ebus.init(config.eventBus);
        }
        if (config.endpoints) {
            this.epFactory.init(config.endpoints);
        }
        //TODO: Add other framework components here ...
        this._state = sysdefs.eModuleState.READY;
        return 'ok';
    }
    /**
     * @param { Object } options
     * @param { string[]?} options.excludeModelPaths - The exclude model paths
     * @param { string? } options.modelDir - The 
     * @param { string[]?} options.excludeModels - The exclude model names 
     * @param { string[]?} options.includeModels - The included model names
     * @returns
     */
    loadDataModels(options) {
        options.excludeModelPaths = _excludeModelPaths.concat(options.excludeModelPaths);
        logger.info('>>>>>> loadDataModels with options: ', tools.inspect(options));
        //
        const modelDir = path.join(appRoot.path, options.modelDir || 'models');
        const loadedModels = [];
        _readModelDirSync.call(this, modelDir, loadedModels, options);
        logger.info(`>>>>>> Total ${loadedModels.length} database schemas registered. <<<<<<`);
        return loadedModels.length;
    }

    loadServices(options) {
        let serviceDir = path.join(appRoot.path, options.serviceDir || 'services');
        logger.info(`>>>>>> Load all services module from ${serviceDir} ...`);
        let allServices = [];
        let entries = fs.readdirSync(serviceDir, {
            withFileTypes: true
        });
        entries.forEach( dirent => {
            if (dirent.isDirectory()  // Recursive not support currently
                || (options.enabledServices && options.enabledServices.indexOf(dirent.name) === -1)) {  
                return null;
            }
            let filePath = path.join(serviceDir, dirent.name);
            try {
                let svc = require(filePath);
                let svcName = this.registry.register(svc);
                allServices.push(svcName);
            } catch (ex) {
                logger.error(`!!! Load service: ${dirent.name} error! - ${ex.message}`);
            }
        });
        logger.debug(`>>> All available services: ${tools.inspect(allServices)}`);
        return allServices;
    }

    //
    // Fire alarm
    async fireAlarm(args, options) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        return false;
        // if (process.env.NODE_ENV !== 'production' && !options.alwaysSend) {
        //     logger.debug(`Ignore fire alarm on development env.`);
        //     return callback();
        // }
        // if (!apmConf) {
        //     logger.warn(`APM server not configed!`);
        //     return callback();
        // }
        // let req = {
        //     url: `${apmConf.baseUrl}/v1/alarm/raise`,
        //     method: 'POST',
        //     json: true,
        //     body: {
        //         service: args.service || this.getServiceAlias(),
        //         instance: this._id,
        //         eventId: args.eventId,
        //         content: args.content
        //     }
        // };
        // logger.debug(`Alarm options: ${tools.inspect(req)}`);
        // req.bodyParser = tools.defaultBodyParser;
        // tools.invokeHttpRequest(req, (err, body) => {
        //     if (err) {
        //         return callback(err);
        //     }
        //     return callback(null, body);
        // });
    }
    /**
     *
     * @param mod
     */
    registerModule(mod, events) {
        logger.info(`New module registry: ${mod.$name} - ${mod.mandatory} - ${mod.state}`);
        if (this._modules[mod.$name] !== undefined) {
            logger.error(`>>>>>> Conflict! ${mod.name} already exists.`)
        } else {
            this._modules[mod.$name] = mod;
            // Add to clean up chain
            let layer = mod.type || sysdefs.eModuleType.OBJ;
            this._arch[layer].push(mod);
        }
    }
    updateModuleState(name, s) {
        assert(name !== undefined);
        assert(sysdefs.isValidModuleState(s));
        if (this._modules[name] !== undefined) {
            this._modules[name].state = s;
            logger.info(name, s);
        } else {
            logger.error(`Unrecognized module name: ${name}`);
        }
    }
    getModuleState(name) {
        return this._modules[name] ? this._modules[name].state : undefined;
    }
    isActive() {
        let active = true;
        let keys = Object.keys(this._modules);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            if (this._modules[key].mandatory === true && this._modules[key].state !== sysdefs.eModuleState.ACTIVE) {
                active = false;
                break;
            }
        }
        return active;
    }
    isMaster = () => {
        return (process.env.NODE_ENV === 'production' && this._isMaster === true);
    }
    updateInnerToken(token) {
        this._prevToken = this._innerToken;
        this._innerToken = token;
    }
    getAuthConfig() {
        return this._security;
    }
    setDebugLevel(args, callback) {
        if (['info', 'debug', 'error'].indexOf(args.level) === -1) {
            return callback({
                code: eRetCodes.BAD_REQUEST,
                message: 'Invalid level!'
            })
        }
        return logger.setRotateFileLevel(args.level, callback);
    }

    async createEndpoints() {
        return 'todo';
    }
    async start() {
        if (this._state !== sysdefs.eModuleState.READY) {
            logger.error('!!! Initializing first.');
            return false;
        }
        await this.epFactory.startAll();
        //Register to the centered regsitry
        //fire app startup alarm
        //Change state to ACTIVE
        return true;
    }
    // Handle graceful Exit
    async gracefulExit() {
        logger.info('>>> Perform system clean-up before exit... <<<');
        //await _fireExitAlarm();
        //
        logger.info(`>>>>>> Stop all modules ...`);

        let layers = Object.keys(this._arch);
        async.eachSeries(layers, (layer, callback) => {
            logger.info(`>>>>>>>> ${layer}: Clean up modules ...`);
            async.eachLimit(this._arch[layer], 4, (m, next) => {
                if (typeof m.dispose !== 'function') {
                    return process.nextTick(next);
                }
                return m.dispose(next);
            }, () => {
                logger.info(`>>>>>>>> ${layer}: all modules disposed.`);
                return callback();
            });
        }, () => {
            logger.info('>>>>>> All modules disposed.');
            _deregService.call(this, () => {
                return
            })
        })
    }
}

// Define module
module.exports = exports = {
    Application
};
