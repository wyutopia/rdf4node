#!/usr/bin/env node
/**
 * Created by Eric on 2021/11/10
 * Updatede by Eric on 2024/01/19
 */
const assert = require('assert');
const async = require('async');
const EventEmitter = require('events');
const fs = require('fs');
const path = require('path');
const os = require('os');
// project libs



const sysdefs = require('../include/sysdefs');
const eRetCodes = require('../include/retcodes');
const tools = require('../utils/tools');
//
const {app: config} = require('../include/config');
const consulClient = (config.consul? require('../libs/base/consul.wrapper') : null);
const {WinstonLogger} = require('../libs/base/winston.wrapper');
const logger = WinstonLogger(process.env.SRV_ROLE || 'rdf4node');

let version = null;
let consulSignIn = false;

function _regService(callback) {
    if (consulClient === null) {
        logger.warn(`>>>>>> Consul not configged! -ignore register service.`);
        return callback();
    }
    let localIp = tools.getLocalIp()[0];
    let port = process.env.PORT || appConf.port || 3000;
    consulClient.regService({
        name: appConf.registry,
        id: this._id,
        tags: appConf.tags,
        address: localIp,
        port: parseInt(port, 10),
        check: {
            http: `http://${localIp}:${port}/monitor/health`,
            interval: '15s'
        }
    }, (err) => {
        if (err) {
            logger.error('Register to consul error!');
        } else {
            logger.info('Register to consul succeed.');
            consulSignIn = true;
        }
        return callback();
    });
}

function _deregService(callback) {
    if (consulClient === null) {
        logger.warn(`>>>>>> Consul not configged! - ignore de-register service.`);
        return callback();
    }
    logger.info('Try to de-register from consul...');
    if (!consulSignIn) {
        logger.error('Not registered!');
        return callback();
    }
    consulClient.deregService({
        id: this._id
    }, (err) => {
        if (err) {
            logger.error('De-register from consul failed.');
        } else {
            logger.info('De-register from consul succeed.');
        }
        return callback();
    });
}

function _raiseStartupAlarm(callback) {
    let options = {
        eventId: sysdefs.eAlarmCode.SERVICE_STARTUP,
        content: 'This is a startup alarm test!'
    }
    return this.fireAlarm(options, callback);
}

function _raiseGracefulExitAlarm(callback) {
    let options = {
        eventId: sysdefs.eAlarmCode.GRACEFUL_EXIT,
        content: 'This is a graceful-exit alarm test!'
    }
    return this.fireAlarm(options, callback);
}

function _buildModuleArch() {
    let arch = {};
    Object.keys(sysdefs.eModuleType).forEach(layer => {
        arch[layer.toLowerCase()] = [];
    });
    return arch;
}

const _typeAppConfig = {
    id: os.hostname(),
    name: 'a9kb',
    alias: 'a9kb-app',
    registry: 'a9kb-app',
    tags: [],
    //
    enableMonitor: false,
    security: {
        ip: false,
        encryptKey: '123abcABC',
        expiresIn: "72h",
        enableRateLimit: false,
        enableAuthentication: true,
        enableAuthorization: false
    },
    rateLimit: {
        options: {
            windowMs: 60000,
            max: 60,
            expireTimeMs: 900000
        },
        store: {
            type: 'mongo',
            confPath: 'dataSources.default.config'
        }
    },
    defaultDataSource: 'default',
    allowedModels: null,    // null means all models
    allowedServices: null   // null means all services
}

function _initApp(props) {
    Object.keys(_typeAppConfig).forEach(key => {
        let propKey = '_' + key;
        if (props[key] === undefined) {
            this[propKey] = _typeAppConfig[key];
        } else {
            this[propKey] = tools.isTypeOfArray(_typeAppConfig[key])? 
                _typeAppConfig[key].concat(props[key]) : Object.assign(_typeAppConfig[key] || {}, props[key])
        }
    })
}

const _excludeModelFolders = ['.DS_Store', '_templates'];
function _readModelDirSync(modelDir, loadedModels) {
    //logger.debug(`====== Scan directory: ${modelDir}`);
    let entries = fs.readdirSync(modelDir, {
        withFileTypes: true
    });
    entries.forEach(dirent => {
        let fullPath = path.join(modelDir, dirent.name);
        if (dirent.isDirectory()) {
            if (_excludeModelFolders.indexOf(dirent.name) !== -1) { // Ignore excluded folers
                return null;
            }
            return _readModelDirSync.call(this, fullPath, loadedModels);
        }
        //
        try {
            const modelSpec = require(fullPath);
            const modelName = modelSpec.modelName;
            if (this.allowedModels && this.allowedModels.indexOf(modelName) === -1) {
                return null;
            }
            //
            let cacheConf = config.caches[modelName] || {};
            // Get allowCache switch
            let allowCache = ((allowCache, config) => { // cache config has the privilege
                return config.enabled !== undefined? config.enabled : (allowCache !== undefined? allowCache : false);
            })(modelSpec.allowCache, cacheConf);
            // Assemble cacheOptions = cacheSpecProps + cacheEntityProps
            let cacheSpec = Object.assign({}, modelSpec.cacheSpec, cacheConf.spec);
            this.repoFactory.registerSchema(modelName, {
                schema: modelSpec.modelSchema,
                refs: modelSpec.modelRefs || [],
                // Cache options
                allowCache,
                cacheSpec 
            });
            logger.debug(`${modelName} cache settings: ${allowCache} - ${tools.inspect(cacheSpec)}`);
            loadedModels.push(modelName);
        } catch (ex) {
            logger.error(`====== Load database schema from: ${dirent.name} error! - ${ex.message}`);
        }
    });
    return null;
}

// The application class
class Application extends EventEmitter {
    constructor(props) {
        super();
        // Declaring member variables
        _initApp.call(this, props);
        this._state = sysdefs.eModuleState.INIT;
        this._consulClient = null;
        //
        this.repoFactory = new RepositoryFactory({$name: 'RepoFactory'})
        //
        (() => {

        })();
    }
    // Implementing member methods
    getName () {
        return this._name;
    }
    getId() {
        return this._id;
    }
    setState(s) {
        this._state = s;
    }
    getState() {
        return this._state;
    }
    fetchServices (callback) {
        return _consulClient.listServices(callback);
    }
    //
    async init() {
        return false;
    }
    /**
     * 
     * @returns
     */
    async loadDatabaseSchemas() {        
        try {
            const modelDir = path.join(appRoot.path, 'models');
            logger.info(`>>> Setp 2: Load all database schemas from ${modelDir} ... <<<`);
            const loadedModels = [];
            _readModelDirSync.call(this, modelDir, loadedModels);
            logger.info(`>>> Total ${loadedModels.length} database schemas registered. <<<`);
            return true;
        } catch (ex) {
            logger.error(`!!! Load database schemas error! - `, ex);
            return Promise.reject(ex);
        }
    }
    async startServices() {
        return false;
    }
    async startEndpoints() {
        return false;
    }
    //
        this.getInstance = () => {
            return this._id;
        }
        this.
        this.fetchServiceNodes = (serviceName, callback) => {
            return consulClient.listServiceNodes(serviceName, callback);
        }
        this.getRegistry = () => {
            return appConf.registry;
        }
        this.setState = (s) => {
            this._state = s;
        }
        // Fire alarm
        this.fireAlarm = (args, options, callback) => {
            if (typeof options === 'function') {
                callback = options;
                options = {};
            }
            return callback();
            // if (process.env.NODE_ENV !== 'production' && !options.alwaysSend) {
            //     logger.debug(`Ignore fire alarm on development env.`);
            //     return callback();
            // }
            // if (!apmConf) {
            //     logger.warn(`APM server not configed!`);
            //     return callback();
            // }
            // let req = {
            //     url: `${apmConf.baseUrl}/v1/alarm/raise`,
            //     method: 'POST',
            //     json: true,
            //     body: {
            //         service: args.service || this.getServiceAlias(),
            //         instance: this._id,
            //         eventId: args.eventId,
            //         content: args.content
            //     }
            // };
            // logger.debug(`Alarm options: ${tools.inspect(req)}`);
            // req.bodyParser = tools.defaultBodyParser;
            // tools.invokeHttpRequest(req, (err, body) => {
            //     if (err) {
            //         return callback(err);
            //     }
            //     return callback(null, body);
            // });
        }
        /**
         *
         * @param mod
         */
        this.regModule = (mod) => {
            logger.info(`New module registry: ${mod.$name} - ${mod.mandatory} - ${mod.state}`);
            if (this._modules[mod.$name] !== undefined) {
                logger.error(`>>>>>> Conflict! ${mod.name} already exists.`)
            } else {
                this._modules[mod.$name] = mod;
                // Add to clean up chain
                let layer = mod.type || sysdefs.eModuleType.OBJ;
                this._arch[layer].push(mod);
            }
        }
        this.setModuleState = (name, s) => {
            assert(name !== undefined);
            assert(sysdefs.isValidModuleState(s));
            if (this._modules[name] !== undefined) {
                this._modules[name].state = s;
                logger.info(name, s);
            } else {
                logger.error(`Unrecognized module name: ${name}`);
            }
        }
        this.getModuleState = (name) => {
            return this._modules[name]? this._modules[name].state : undefined;
        }
        this.isActive = () => {
            let active = true;
            let keys = Object.keys(this._modules);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                if (this._modules[key].mandatory === true && this._modules[key].state !== sysdefs.eModuleState.ACTIVE) {
                    active = false;
                    break;
                }
            }
            return active;
        }
        this.gracefulExit = () => {
            logger.info('>>>>>> Perform system clean-up before exit <<<<<<');
            _raiseGracefulExitAlarm.call(this, () => {
                logger.info(`>>>>>> Stop all modules ...`);
                let layers = Object.keys(this._arch);
                async.eachSeries(layers, (layer, callback) => {
                    logger.info(`>>>>>>>> ${layer}: Clean up modules ...`);
                    async.eachLimit(this._arch[layer], 4, (m, next) => {
                        if (typeof m.dispose !== 'function') {
                            return process.nextTick(next);
                        }
                        return m.dispose(next);
                    }, () => {
                        logger.info(`>>>>>>>> ${layer}: all modules disposed.`);
                        return callback();
                    });
                }, () => {
                    logger.info('>>>>>> All modules disposed.');
                    _deregService.call(this, () => {
                        return process.exit(0);
                    });
                });
            });
        }
        this.isActive = () => {
            return this._state === sysdefs.eModuleState.ACTIVE;
        }
        this.setInnerToken = (token) => {
            this._prevToken = this._innerToken;
            this._innerToken = token;
        }
        this.getAuthConfig = () => {
            return this._config.auth;
        }
        this.setConfigAsync = (args, callback) =>{
            if (args.token !== Buffer.from(config.accToken, 'base64').toString()) {
                logger.error('Invalid secret!');
                return callback({
                    code: eRetCodes.FORBIDDEN,
                    message: 'Invalid secret!'
                });
            }
            let conf = sysdefs.extractValidConfig(args);
            this._config = Object.assign(this._config, conf);
            return callback(null, this._config);
        }
        this.setDebugLevel = (args, callback) => {
            if (['info', 'debug', 'error'].indexOf(args.level) === -1) {
                return callback({
                    code: eRetCodes.BAD_REQUEST,
                    message: 'Invalid level!'
                })
            }
            return logger.setRotateFileLevel(args.level, callback);
        }
        /**
         * Get configuration data
         * @returns {*}
         * @param path
         * @param callback
         */
        this.getConfigAsync = (path, callback) => {
            let val = undefined;
            try {
                let keys = path.split('.');
                let i = 0;
                val = this._config[keys[i++]];
                while (i < keys.length) {
                    val = val[keys[i++]];
                }
                return callback(null, val);
            } catch (ex) {
                return callback(ex);
            }
        }
        this.getConfig = (path) => {
            try {
                let keys = path.split('.');
                let i = 0;
                let val = this._config[keys[i++]];
                while (val !== undefined && i < keys.length) {
                    val = val[keys[i++]];
                }
                return val;
            } catch (err) {
                logger.error(__file, __line, path, err.code, err.message);
            }
        }
        this.getSysConfig = (req, res) => {
            if (req.query.token !== Buffer.from(config.accToken, 'base64').toString()) {
                return res.sendRsp(eRetCodes.FORBIDDEN, 'Access denied!');
            }
            return res.sendSuccess(this._config);
        }
        this.getVersion = (req, res) => {
            if (version === null) {
                version = JSON.parse(fs.readFileSync(path.join(__dirname + '/../conf/version.json')).toString());
            }
            return res.sendSuccess(version);
        }
        this.isMaster = () => {
            return (process.env.NODE_ENV === 'production' && this._isMaster === true);
        }
        (() => {
            let beginTime = new Date();
            logger.info('>>>>>> System initializing <<<<<<');
            async.parallel({
                regService: _regService.bind(this),
                fireStartupAlarm: _raiseStartupAlarm.bind(this)
            }, () => {
                logger.info(`>>>>>> System startup in ${new Date().valueOf() - beginTime.valueOf()}ms`);
                this._state = sysdefs.eModuleState.ACTIVE;
                return null;
            });
        })();
    }
}

let theApp = new TheApp(config);
process.on('SIGINT', () => {
    logger.info('>>>>>> On SIGINT <<<<<<');
    theApp.setState(sysdefs.eModuleState.STOP_PENDING);
    theApp.gracefulExit();
});

module.exports = exports = theApp;
